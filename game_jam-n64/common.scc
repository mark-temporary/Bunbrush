/* SCUNK
 * Copyright (C) 2025 Mark Bauermeister
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 */

// include all the vars used by the engine itself
#include <scummVars6.s>
#include "common.sch"
#include "inventoryitems.sch"
#include "verbs.sch"
#include "actors.sch"
#include "classroom.sch"
#include "title.sch"
#include "text/en.sch"

room ResRoom {
    image = "graphics/rooms/shop.bmp";

    boxd = "graphics/rooms/empty_room.box";
    zplane = { "graphics/rooms/empty_room-z.bmp" };
    trans = 0;
    // cycle Cycl = { 10, 0, 102, 110};
    // Define the charset we are going to use
    // The GUI uses the first charset, so be sure to force its address
    chset chset1 @ 1 = "vera-gui.char";
    // Our game's standard charset
    chset chtest = "vera.char";
    // dialog charset
    chset dialogCharset = "vera-small.char";

    chset imageChset = "ruigslay.char";

    int selVerb,altVerb;
    int tryPick;

    // some startup scripts


    // this script runs in the background, checking where the mouse is
    // and updating the sentence/setting the alt verb
    script mouseWatch() {
        int vrb,obj,target,alt,desc,act;

        // we run forever (well ... until someone kills the process)
        while(1) {
            obj = getObjectAt(VAR_VIRT_MOUSE_X,VAR_VIRT_MOUSE_Y);
            act = getActorAt(VAR_VIRT_MOUSE_X,VAR_VIRT_MOUSE_Y);
            delay(1);
            printAt(VAR_VIRT_MOUSE_X,VAR_VIRT_MOUSE_Y - 20);
            print("%n{obj}%n{act}");

            unless(cursorOn) {
                if(altVerb) {
                    setCurrentVerb(altVerb);
                    setVerbOn();
                    redrawVerb();
                    altVerb = 0;
                }
                do breakScript() until(cursorOn);
                        
            }
            if(isScriptRunning(VAR_SENTENCE_SCRIPT)) {
                 breakScript();
                continue;
            }

            // read the current state

            // find what verb should be displayed and the
            // object under the pointer
            vrb = 0;
            desc = 0;

            obj = getObjectAt(VAR_VIRT_MOUSE_X,VAR_VIRT_MOUSE_Y);

            unless(obj) {
                obj = getActorAt(VAR_VIRT_MOUSE_X,VAR_VIRT_MOUSE_Y);
                if(obj == VAR_EGO)
                    obj = 0;
                else if (actorObject[obj])
                    desc = actorObject[obj];
            }

            unless(obj) {
                obj = getVerbAt(VAR_MOUSE_X,VAR_MOUSE_Y);
                if(obj >= invSlot0 && obj <= invSlot7) {
                    obj = findInventory(VAR_EGO,obj-invSlot0+1+invOffset);
                    if(!selVerb || selVerb == Interact)
                        vrb = Interact;
                    else
                        vrb = Interact;
                } else
                    obj = 0;
            }
            unless(vrb)
                vrb = selVerb ? selVerb : Interact;                    
            
            // Set description object
            unless(desc)
            	desc = obj;
            
            if(sntcPrepo) {
                target = sntcObjB;
                if(obj == sntcObjA) {
                	obj = 0;
                	desc = 0;
                }
            } else target = sntcObjA;
            
            ////dbgPrint("%i{vrb} <> %i{sntcVerb} | %i{obj} <> %i{target}");
            unless(vrb == sntcVerb && obj == target) {
                sntcVerb = vrb;
                
                // Set sentence line
                if(sntcPrepo) {
                	sntcObjB = obj;
                	sntcObjBDesc = desc;
                }
                else {
                	sntcObjA = obj;
                	sntcObjADesc = desc;
                }
                
                setCurrentVerb(SntcLine);
                redrawVerb();
            }


            if(obj) {
                if(obj is Person)
                    alt = Interact;
                else if(obj is Openable)
                    alt = Interact;
                else
                    alt = Interact;
            } else
                alt = 0;

            if(alt != altVerb) {
                if(altVerb) {
                    setCurrentVerb(altVerb);
                    setVerbOn();
                    redrawVerb();
                }
                if(alt) {
                    setCurrentVerb(alt);
                    verbDim();
                    redrawVerb();
                }
                altVerb = alt;
            }

            breakScript();
        }
    }



    // setup the cursor
    script showCursor() {
        if(cursorOn) return;

        cursorOn();
        userPutOn();
        cursorOn = 1;
    }

    script hideCursor() {
        unless(cursorOn) return;
        
        cursorOff();
        userPutOff();
        cursorOn = 0;
    }

    script cutsceneStart(int type) {
        //dbgPrint("cutscene start");
        hideCursor();
        if(type > 0) {
            // We need to break here to make sure the mouse watch script
            // stop. Otherwise it might turn on the alt verb again,
            breakScript();
            Verbs::showVerbs(0);
        }
    }

    script cutsceneEnd(int type) {
        //dbgPrint("cutscene end");
        showCursor();
        if(type > 1)
            Verbs::showVerbs(1);
    }

    script resetSntc(int vrb) {
        sntcObjA = 0;
        sntcObjADesc = 0;
        if(sntcPrepo) {
            undim(sntcPrepo);
            sntcObjB = 0;
            sntcObjBDesc = 0;
        }
        selVerb = vrb;
        setCurrentVerb(SntcLine);
        redrawVerb();
    }

    script defaultAction(int vrb, int objA, int objB) {
        switch(vrb) {
        case WalkTo:
        case Interact:
            return;
            
        // case PickUp:
        //     // If the object is pickable and use an object from the
        //     // inventory room
        //     // Note: Add sound/egosay code for objects here
        //     if(objA is Pickable && getObjectVerbEntrypoint(objA,InventoryObject)) {
        //         startObject2(objA,InventoryObject, [ InventoryObject, objA ]);
        //         if(VAR_RETURN) {
        //             waitForMessage();
        //             pickupObject(VAR_RETURN, InventoryItems);
        //             setObjectClass(objA,[ 0x80 + ClassUntouchable ]);
        //             setObjectState(objA, 0);
        //             return;
        //         }
        //     }
        //     if(objA is Person)
        //         egoSay("I don't need them.");
        //     else
        //         egoSay("I don't need that.");
        //     break;

        default:
            egoSay("Hmm. No.");
            break;
        }
        waitForMessage();
    }

    // the sentence script, doSentence call it
    script sentenceHandler(int vrb, int objA, int objB) {
        int owner,tmp,act;

        // click on the sentence line, make it as if the user
        // clicked the currently selected objects
        if(vrb == SntcLine) {
            vrb = sntcVerb;
            objA = sntcObjA;
            objB = sntcObjB;
        }

        // look who own the object
        owner = getObjectOwner(objA);

        // with use and give we must own it first
        while(isAnyOf(vrb, [ Interact ])) {
            unless(objB) {
                if(getObjectVerbEntrypoint(objA,Preposition)) {
                    startObject2(objA,Preposition,[ vrb, objA ]);
                    if(sntcPrepo) {
                        setCurrentVerb(SntcLine);
                        redrawVerb();
                        return;
                    }
                }
                break;
            }

            // we must pick it up first
            if(owner != VAR_EGO) {
                if(tryPick == objA) { // pickup failed
                    tryPick = 0;
                    return;
                }
                // if a different object is used once it is in the inventory
                // use this one when resending the sentence
                if(getObjectVerbEntrypoint(objA,InventoryObject)) {
                    startObject2(objA,InventoryObject,[ InventoryObject, objA ]);
                    tryPick = VAR_RETURN;
                } else
                    tryPick = objA;
                // try to pickup then do our action again
                doSentence(vrb,tryPick,0,objB);
                // doSentence(PickUp,objA,0,0);
                return;
            } else
                tryPick = 0;
            break;
        }
        
        // if the object is in the room walk there
        if(objA <= 0xF || owner == 0xF) {
            walkActorToObj(VAR_EGO,objA,0);
            waitForActor(VAR_EGO);
            // This is needed when walking to an actor
            if(objA <= 0xF)
                actorFace(VAR_EGO,objA);
        } else if(objB) if(objB <= 0xF || getObjectOwner(objB) == 0xF) {
            walkActorToObj(VAR_EGO,objB,0);
            waitForActor(VAR_EGO);
            if(objB <= 0xF)
                actorFace(VAR_EGO,objB);
        }

        // Take the actorObject if it exist
        if(objA <= 0xF) if(actorObject[objA]) {
            act = objA;
            objA = actorObject[objA];
        }

        // if the object implement the verb call that
        if(getObjectVerbEntrypoint(objA,vrb)) {
            startObject(2,objA,vrb,[ vrb, objA, objB ]);
            // if the verb locked the cursor wait until its unlocked
            do breakScript() until(cursorOn);
        } else {
            //otherwise use our default:
            defaultAction(vrb, act ? act : objA, objB);
 
        }
        // if the verb need objB we are done for now
        if(sntcPrepo && !objB) return;

        // all done, reset the sentence
        resetSntc(0);
    }

    script keyboardHandler(int key) {
        switch(key) {
        case 'o':
            egoSay("Hooo");
            break;
        case 'r':
            egoSay("Let's restart.");
            waitForMessage();
            restartGame();
            break;
        case 'q':
            shutdown();
            break;
        }
    }

   // This script receive the keyboard and mouse events
    script inputHandler(int area,int cmd, int btn) {
        int vrb,obj,objB,x;
        int invCount,invOffsetMax;

        //dbgPrintBegin();
        //dbgPrint("Area=%i{area} cmd=%i{cmd} button=%i{btn}");
        //dbgPrintEnd();

        egoPrintBegin();
        egoPrintOverhead();
        actorPrintEnd();

        if(area == 4) { // area 4 is the keyboard
            keyboardHandler(cmd);
            return;
        }

        // A verb was clicked
        if(isAnyOf(cmd, [ Interact ])) {
            resetSntc(cmd);
            return;
        }


        if(cmd == invUp || cmd == invDown) {
            invCount = getInventoryCount(VAR_EGO);
            invOffset += (cmd == invUp ? -1 : 1)*INVENTORY_COL;
            invOffsetMax = ((invCount+INVENTORY_COL-1)/INVENTORY_COL -
                            INVENTORY_LINE)*INVENTORY_COL;
            if(invOffset > invOffsetMax)
                invOffset = invOffsetMax;
            if(invOffset < 0) invOffset = 0;
            //dbgPrint("Inventory offset: %i{invOffset}");
            Verbs::showVerbs(1);
            inventoryHandler( 0 );
            return;
        }


        // now are left: room click and inventory
        // stop any currently running sentence
        stopSentence();
        // (re)start the mouse script, giving it a chance to update
        // the sentence.
        // Note that it's a non recursive call hence it will kill the script
        // then start it again.
        mouseWatch();

        // button 2 was clicked but not on an object
        if(btn == 2) unless(sntcPrepo ? sntcObjB : sntcObjA) {
            // stop walking
            setCurrentActor(VAR_EGO);
            setActorStanding();
            resetSntc(0);
            return;
        }

        // an object was clicked
        if(sntcPrepo ? sntcObjB : sntcObjA) {
            // an inventory object was cliked
            // select the verb that is displayed
            // We need this to keep Use when PickUp
            // was originaly selected
            if(cmd) selVerb = sntcVerb;
            // button 2: select the alternat verb
            if(btn == 2 && altVerb) {
                selVerb = altVerb;
                mouseWatch();
            }
            // queue the sentence
            doSentence(sntcVerb,sntcObjA,0,sntcObjB);
            return;
        }
        // click on nothing, ignore non room clicks
        if(area != 2) return;

        // reset the sentence so we get WalkTo again
        if(selVerb) resetSntc(0);
        
        // then go there
        walkActorTo(VAR_EGO,VAR_VIRT_MOUSE_X,VAR_VIRT_MOUSE_Y);
    }

    script setInventoryIcon(int icon, int slot) {
        setCurrentVerb(slot);
        setVerbObject(icon,InventoryItems);
        redrawVerb();
    }

    script inventoryHandler(int obj) {
        int i, count;
        //unless(obj) return;

        count = getInventoryCount(VAR_EGO);

        //dbgPrint("%i{count} obj in inv");


        for(i = 0 ; i < INVENTORY_SLOTS ; i++) {
            if(i+invOffset < count) {
                obj = findInventory(VAR_EGO,i+1+invOffset);
                setInventoryIcon(obj,invSlot0+i);
            } else {
                setCurrentVerb(invSlot0+i);
                setVerbNameString(0);
                redrawVerb();
            }
        }

    }

    script preEntry() {
        // Load the actors object for actors moving
        // between several rooms
        Actors::loadObjects();
        loadObjects();
    }

    script quit() {
        shutdown();
    }

    // The main script is the first thing started by the engine.
    // At that point no room is loaded yet.
    script main (int bootParam) {
        int i,j;

        // First setup the engine a bit.
        // For this simple example, we'll only set the menu key (F5)
        // and the restart key (F8), as well as `.` to skip text.
        VAR_MAINMENU_KEY = 319;
        VAR_RESTART_KEY = 322;
        VAR_TALKSTOP_KEY = 46;

        VAR_GAME_VERSION = 0;
        VAR_GUI_COLORS[0] = [ 0x00, 0x00, 0x43, 0x00, 0xD7, 0x34, 0x52, 0x90, 0x00, 0x6A,
                              0x06, 0x1A, 0xD5, 0xE5, 0xE3, 0xE5, 0xE3, 0xE5, 0xE3, 0xE5,
                              0xE3, 0x00, 0x00, 0x00, 0x00, 0x14, 0xD7, 0xE5, 0xE3, 0xE5,
                              0xE3, 0x37, 0x1C, 0xE5, 0xE3, 0xE5, 0xE3, 0x14, 0xD7, 0xE5,
                              0xE3, 0xE5, 0xE3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ];

        // We only set the restart message.
        // Theoretically, we could set the GUI colors here 
        // but this example should be kept to a minimum and ScummVM currently uses its own color scheme anyways.
        VAR_RESTART_MSG[0] = "Are you sure you want to restart? (Y/N)Y";

        // set the main loop speed
        // TODO increase to `1` to make it 66.6 FPS.
        // Requires changes to all animations.
        VAR_TIMER_NEXT = 2;
        
        // set the input handler
        VAR_VERB_SCRIPT = inputHandler;
        VAR_SENTENCE_SCRIPT = sentenceHandler;
        VAR_INVENTORY_SCRIPT = inventoryHandler;
        VAR_CUTSCENE_START_SCRIPT = cutsceneStart;
        VAR_CUTSCENE_END_SCRIPT = cutsceneEnd;
        VAR_PRE_ENTRY_SCRIPT = preEntry;

        // keep this room in memory even if we leave it,
        // as it contain the charset, costume, etc
        // it's probably not very useful atm bcs we only have one
        // room, but well :)
        loadRoom(ResRoom);
        lockRoom(ResRoom);

        loadRoom(ClassRoom);
        lockRoom(ClassRoom);

        // Initialize the graphic mode.
        // It need to match the room image height otherwise
        // the graphics are going wacky
        
        // doLua("Engine:setScreen(0,144)");
        setScreen(0,200);
        // doLua("Room:setScreen(0,144)");

        // Create the actor -> obj link
        dimInt(actorObject,0x10);

        // init the charset
        //initCharset(chset1);
        initCharset(chtest);


        showCursor();

        mouseWatch();

        // init the print slot for actor talking
        printBegin();
        printCenter();
        printOverhead();
        printEnd();

        // do the box effect
        // screenEffect(0x0005);
        // start the room
        // startRoom(ClassRoom);
        startRoom(TitleScreen);
    }
    object inventoryPopup {
        states = {
            // { 0, 0, "graphics/inventory_items/inventory.bmp" }
            {0, 0, "graphics/inventory_items/inventory2.bmp",
             {"graphics/inventory_items/inventory-z.bmp", ""}}
        };

        state = 0;
        trans = 0;
    }
    // This script is called on pre-entry to load the actor
    // objects from this room
    script loadObjects() {
        setObjectClass( inventoryPopup, [ 0x80 + ClassUntouchable ] );
        setObjectClass( inventoryPopup, [ 0x80 + ClassIgnoreBoxes] );

        loadFlObject(inventoryPopup,ResRoom);

    }
}
